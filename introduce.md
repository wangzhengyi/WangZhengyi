# 自我介绍

> 老师好,我叫王正一,目前就读于中国传媒大学计算机应用专业,研究方向是互联网应用技术和服务器端研发.我想从一下两个方面介绍自己:

## 学习方面

> 我喜欢开源文化,热衷于技术分享,在github上有自己的开源项目(例如：多音字转拼音类库),技术博客每月都会更新自己的学习心得.有一定代码洁癖,读研期间参考fig-standards制定了项目组的php协作代码规范,休闲时间喜欢读书、喜欢刷ACM题目,在九度oj平台AC 300+,总排名前十

## 实践方面
> 读研期间,参加了导师主导的创业项目-好联系通讯录,主打实名制社交.我在公司主要从事研发和运维工作.研发方面主要负责了黄页搜索,消息系统,圈子系统,准信系统等重要功能模块的设计和实现,运维方面主要负责架构设计和搭建,期间完成了公司从apache2+mod_php到nginx+php5_fpm的架构迁移。目前渴望遇到大并发和大数据的挑战


# 牛逼项目

> 我感觉做的比较好的项目是用户消息系统。这个项目的亮点在于

>> 1. 合理利用Redis提供的数据结构设计Redis数据库，存储关系型数据

>> 2. 根据对TCP三次握手的理解，设计了消息实时读取算法


## 项目E-R关系

> 实体：用户（uid或手机号码进行标识），终端（token），消息（mid），用户和终端是1:n关系，用户和消息是n:n的关系

> 需求：用户在自己的每个终端都能实时获取最新的服务器端发送消息

> 弊端：之前用mysql进行消息存储，查询速度慢，创建消息混乱，时常出现丢失消息的情况。Redis提供了多种数据结构，内存存储数据查询速度快，AOF日志或RDB文件保证数据不丢失


## Redis数据库设计

> 首先利用了redis的hashes，string，sorted_sets数据结构。具体key的设计采用了前缀+唯一标识的方法，这里用户的标识是uid，终端标识是token，消息标识是mid。

>> 注册用户信息存储在Mysql里，不需要迁移到redis中。

>> 采用string数据结构设计了终端-用户对应关系表，key为client_[token]，value为uid，用户访问服务器端API接口我们可以获取用户token，查询此表即可获取当前用户uid，需要查询用户信息可利用uid查询mysql。

>> 采用hashes数据结构设计了消息存储结构表，key为msg_[$mid]，这里mid全局唯一，类似于mysql的主key，采用redis的incr原子操作实现。value是一个二层结构，域分别是消息标题，副标题，时间戳等消息属性。

>> 利用sorted_sets设计了用户-未读消息队列和用户-已读消息队列，以未读消息队列为例，key为unread_mids_[$uid],value是消息的mid集合，排序属性是消息的ts

>> 同时为了用户体验，防止不同终端有遗漏或多发送消息的情况，利用sets数据结构设计了终端-消息对应关系表，key为unread_mids_[$token]，value为该终端已经接收的消息mid集合

> 到这里，这种Redis数据库设计完成，可以表示出我上面描述的业务E-R模型

## 消息读取算法

> 采用了tcp三次握手思想，客户端在获取服务器端发送的消息之后需要将这次已经接收的消息mid再告知服务器端。有四个主要的api设计，分别是ping, update, updateack, read, 下面我简要介绍一下这四个接口：

>> 1. ping: 查看用户未读消息队列，有未读消息，则需要通过update向服务器端拉取消息集合

>> 2. update: 获取用户未读消息队列和终端未读消息队列，两者diff差集即为用户未读消息集合，按照时间戳从高到低分页返回给客户端

>> 3. updateack: 客户端收到未读消息mid集合后，需要再次告知服务器端， 服务器端将这些mid集合放到终端-消息结构表中，这样下次用户请求update时就不会返回已经发送的信息了

>> 4. read: 客户端发送mid，服务器端根据mid获取hashes存储的消息体内容

> 这种算法设计可以保证用户实时获取最新消息,用siege做压力测试，siege -R $siege_rc -c $current -r $repeat -i -b -A "$user_agent" -f $urls，在150并发，重复200次情况下表现很好
