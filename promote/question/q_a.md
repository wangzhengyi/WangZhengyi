# 网络框架

#### 如何解耦?

1. **针对接口编程，不针对具体实现编程，对实现细节进行高度封装，对外只暴漏功能接口.**
2. **多用组合，少用继承.**
3. **高内聚，低耦合，每个系统模块只负责自己的业务项目，其实现不依赖于其他系统模块.**

例如：

* 对网络请求进行高度封装,抽象出请求的URL，请求参数等关键信息。那么对于网络请求类来说，它就可以不依赖于具体的Request实现，就能获取发起网络请求的关键信息，进行数据访问。
* 而且清晰的分出了几大块系统架构，使得每个系统都高内聚低耦合。

#### 如何设计缓存机制

1. 首先需要理解HTTP的缓存机制.我们常用的HTTP请求分为GET请求和POST请求，如果通过GET请求访问一个相对持久存储的资源，我们就可以利用HTTP的缓存机制对GET请求进行缓存.
HTTP的request和response都包含了HTTP HEADER和HTTP BODY，HTTP HEADER中保存了跟HTTP Cache缓存相关的信息.

* cache-control字段: no-cache和no-store代表服务器不进行该请求资源的缓存.max-age:指定了当前资源的缓存有效时间.
* Expires,Last-Modified,ETag字段获取请求资源的过期时间，最后修改时间以及资源标识。

2. 设计缓存请求实体类.主要包括：HTTP请求体，请求访问时间，缓存过期时间，缓存资源标识等.

3. 使用系统提供的LruCache类实现L1级内存缓存.

4. 使用context.getCacheFile()获取L2硬盘缓存目录，并且根据请求访问时间进行FIFO缓存替换机制。


#### 如何提高了并发效率?

采取了如下措施:

1. 使用线程池。使用Executors.newFixedThreadPool(4);
2. 使用阻塞队列PriorityBlockingQueue来调度网络请求线程。


#### 相比于市面上的网络框架，优势：

1. 高内聚，低耦合，框架易用。
2. Vollley不研究源码会给使用者带来迷惑，误用缓存机制。而我的框架提供了全局单例类，不会出现误用和资源浪费的情况。
3. 更完善的缓存系统。对比Volley，首先增加了支持LRU算法的内存缓存，同时硬盘缓存提供了FIFO的替换策略，增加缓存命中率。
4. 支持HTTPS，更好的支持服务器自签名证书(需要复习).


## Android内部解耦

如何解耦的？

1. 传给支付宝SDK的UI类，只是在不同的UI回调方法中向EventBus总线发送自己的UI事件。
2. 实现一个BaseActivity，在baseactivity中的oncreate函数中向EventBus注册自己的订阅函数，监听common的ui变化。在onDestory方法中，注销.
3. 特定的Activity只需要继承BaseActivity，有需要被回调的UI显示则增加特定的UI函数即可。

EventBus的原理:

1. Activity的注册利用了Java的反射机制，根据对象获取其Class类类型，然后遍历每个循环响应函数.响应函数的标识为存在@Subscribe注解。对于每个响应函数，我们构建订阅事件-订阅函数的Map集合，同时也构造订阅函数-订阅事件的map集合。
2. 发布事件后，查询EventBus的订阅事件-订阅函数集合，找出订阅函数，并通过反射回调订阅函数响应订阅事件。 
