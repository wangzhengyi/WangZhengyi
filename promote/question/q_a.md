# ROM适配

#### 解决的一个难点问题

问题描述：如何解决uuid属性设置问题.UUID注册模块的需要在本地设置一个ro.yunos.uuid的属性，但是属性的设置是由init模块的控制的，每个属性的设置都需要有相应的权限。像这个属性就需要有root权限才能进行设置，而在应用层非root机型最多只能获取system权限。

YunOS的模块可以修改boot分区的init模块源码，从而可以直接降级这个属性的设置权限。而MTK机型拼包适配只有init的二进制文件，是没法修改init源码的。针对这种情况，我设计了如下的解决方案：

1. 修改UUID源码，先设置一个system权限可配置的trigger属性。
2. 编写一个c代码，编译成二进制程序放在bin目录中，作用是：设置ro.yunos.uuid属性。
2. 在init.rc文件，增加一个属性trigger，当配置的trigger属性为设置值时，启动这个二进制程序进行设置。而这个二进制程序的运行权限就是root权限了。

#### 分析Android系统日志

Android日志分为kernel、radio、event和main四大种类.

kernel: kernel log属于系统内核的log，通过读取/proc/kmsg文件获取.
radio: 属于Android RIL层log，可以adb logcat -b参数获取.
main: 是我们应用层打出的log，adb logcat默认输出的就是main log, -b main也行.
event: 属于system log，可以通过adb logcat -b event获取.

#### 替换的动态库




# 网络框架

#### 如何解耦?

1. **针对接口编程，不针对具体实现编程，对实现细节进行高度封装，对外只暴漏功能接口.**
2. **多用组合，少用继承.**
3. **高内聚，低耦合，每个系统模块只负责自己的业务项目，其实现不依赖于其他系统模块.**

例如：

* 对网络请求进行高度封装,抽象出请求的URL，请求参数等关键信息。那么对于网络请求类来说，它就可以不依赖于具体的Request实现，就能获取发起网络请求的关键信息，进行数据访问。
* 而且清晰的分出了几大块系统架构，使得每个系统都高内聚低耦合。

#### 如何设计缓存机制

1. 首先需要理解HTTP的缓存机制.我们常用的HTTP请求分为GET请求和POST请求，如果通过GET请求访问一个相对持久存储的资源，我们就可以利用HTTP的缓存机制对GET请求进行缓存.
HTTP的request和response都包含了HTTP HEADER和HTTP BODY，HTTP HEADER中保存了跟HTTP Cache缓存相关的信息.

* cache-control字段: no-cache和no-store代表服务器不进行该请求资源的缓存.max-age:指定了当前资源的缓存有效时间.
* Expires,Last-Modified,ETag字段获取请求资源的过期时间，最后修改时间以及资源标识。

2. 设计缓存请求实体类.主要包括：HTTP请求体，请求访问时间，缓存过期时间，缓存资源标识等.

3. 使用系统提供的LruCache类实现L1级内存缓存.

4. 使用context.getCacheFile()获取L2硬盘缓存目录，并且根据请求访问时间进行FIFO缓存替换机制。


#### 如何提高了并发效率?

采取了如下措施:

1. 使用线程池。使用Executors.newFixedThreadPool(4);
2. 使用阻塞队列PriorityBlockingQueue来调度网络请求线程。


#### 相比于市面上的网络框架，优势：

1. 高内聚，低耦合，框架易用。
2. Vollley不研究源码会给使用者带来迷惑，误用缓存机制。而我的框架提供了全局单例类，不会出现误用和资源浪费的情况。
3. 更完善的缓存系统。对比Volley，首先增加了支持LRU算法的内存缓存，同时硬盘缓存提供了FIFO的替换策略，增加缓存命中率。
4. 支持HTTPS，更好的支持服务器自签名证书(需要复习).


#### 如何解析Http Header?

1. 需要获取Http Header字段.

```java
connection.getHeaderFields(); // Map<String, List<String>>
```


## Android内部解耦

如何解耦的？

1. 传给支付宝SDK的UI类，只是在不同的UI回调方法中向EventBus总线发送自己的UI事件。
2. 实现一个BaseActivity，在baseactivity中的oncreate函数中向EventBus注册自己的订阅函数，监听common的ui变化。在onDestory方法中，注销.
3. 特定的Activity只需要继承BaseActivity，有需要被回调的UI显示则增加特定的UI函数即可。

EventBus的原理:

1. Activity的注册利用了Java的反射机制，根据对象获取其Class类类型，然后遍历每个循环响应函数.响应函数的标识为存在@Subscribe注解。对于每个响应函数，我们构建订阅事件-订阅函数的Map集合，同时也构造订阅函数-订阅事件的map集合。
2. 发布事件后，查询EventBus的订阅事件-订阅函数集合，找出订阅函数，并通过反射回调订阅函数响应订阅事件。


-------
# 为什么升你为资深开发工程师?(等类似问题)

1. 首先，在过去的两年时间里，我的主管和我的师兄给了我很多技术指导，加上项目的锤炼和个人努力，我认为自己的技术水平已经完成超过p6的技术要求，并且自身的技术广度更加全面.
2. 然后，在过去的一年时间里，由于主管的信任，个人已独立负责业务项目，并且所负责的业务项目都很好的完成了既定目标，我认为自己具备了独当一面的能力。
3. 最后，个人也比较注重技术的分享和传承，能够在组内帮助新人快速融入研发体系，也能在小组内进行很好的串联。

因此，我认为自己已经能够胜任p6的职位。

-------
# 升到p6之后有什么规划，给组内带来什么贡献？


-------
# 之后有什么规划？


-------
# 为什么能称之为技术亮点?

1. 之所以能被称之为技术亮点，首先是因为它确实解决了一个存在的技术难题。
2. 第二个原因是：代码实现过程中，架构清晰，面向接口编程而不是面向实现编程，多用组合少用继承，使得模块耦合度低，易于扩展。
3. 第三个就是：技术亮点模块加入之后，在实现上确实取得了更好的效果。

------
# 除了ppt之上还遇到了哪些难题？

在全智能手表项目中实现应用统一的右滑退出功能。

最初的解决方案是:
实现了一个右滑退出的控件，让每个应用集成，作为每个应用布局的顶级ViewGroup，从而实现右滑退出功能。

但是这种解决方案面临了一些问题：

1. 虽然能够右滑退出，但是每个应用都去集成让代码变得冗余。
2. 项目中有一些模块是apk集成的，拿不到源码，因此无法集成该控件实现右滑退出功能。

针对这些问题，我深入学习了View的touch事件传递机制，从Framework层入手，在顶层View的DecorView中集成了右滑退出控件，实现了右滑退出功能。这样实现之后，应用层代码不需要增加一行代码即具备了右滑退出功能.
